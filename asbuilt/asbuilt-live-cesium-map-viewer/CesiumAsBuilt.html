<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <!-- Include the CesiumJS JavaScript and CSS files -->
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.84/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.84/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
</head>
<style>
  body {
    background-color: linen;
    overflow-y: hidden;
  }

  .container {
    display: grid;
    grid-template-columns: 100%;
    grid-template-rows: 5px auto 20px 150px;
    height: 100vh;
  }

  #cesiumContainer {
    overflow: hidden;
  }

  .settings {
    display: grid;
    grid-template-columns: 60% 30% 10%;
    grid-template-rows: 100%;
  }

  label {
    padding-left:20px;
    text-transform: uppercase;
    display:inline-block;
    white-space: nowrap;
  }

  .separator {
    display: block;
  }

  .firstCol label {
    padding-top: 5px;
    width: 80px;
  }

  .secondCol label {
    padding-top: 5px;
    width: 130px;
  }

  .editItem {
    display: flex;
    height:30px;
    padding-bottom: 5px;
  }

  .editItem input[type=text] {
    width: 98%;
    margin-left: 4px;
  }

  .editItem input[type="checkbox"] {
    margin-top: 5px;
  }

  .colorLegend {
    position: absolute;
    top: 40%;
    right: 0;
    transform: translateY(-40%);
    background: hsla(0,0%,100%,.5);
    padding: 10px;
    border-top-left-radius: 8px;
    border-bottom-left-radius: 8px;
    font-size: 0.8em;
  }

  .legendItem {
    width: 150px;
    padding: 6px;
    color: black;
    border: 1px solid black;
    text-align: center;
    font-weight: bold;

    + .legendItem {
      margin-top: 4px;
    }
  }

  .button {
    background-color: #4CAF50;
    border: none;
    color: white;
    padding: 5px 10px;
    text-align: center;
    display: inline-block;
    font-size: 16px;
    width: 80px;
    height: 30px;
  }
</style>
<body>
  <div class="container">
  <div class="separator"></div>
  <div id="cesiumContainer"></div>
  <script>
    // Your access token can be found at: https://cesium.com/ion/tokens.
    Cesium.Ion.defaultAccessToken = '';

    var viewer = new Cesium.Viewer("cesiumContainer", {
      shouldAnimate: true,
      imageryProvider : Cesium.createWorldImagery({
        style: Cesium.IonWorldImageryStyle.AERIAL_WITH_LABELS
      }),
    });

    var now = new Date();
    const start = now.toISOString();
    now.setMonth(now.getMonth() + 1);
    const end = now.toISOString();

    // refresh every 15s
    var times = Cesium.TimeIntervalCollection.fromIso8601({
      iso8601: `${start}/${end}/PT15S`,
      leadingInterval: true,
      trailingInterval: true,
      isStartIncluded: false,
      isStopIncluded: false,
    });
  </script>
  <div class="separator"></div>
  <div class="settings" id="settings">
    <div class="firstCol">
      <div class="editItem">
        <label>Env:</label>
        <select id="env">
          <option value="QA">QA</option>
          <option value="PROD">Production</option>
        </select>
      </div>
      <div class="editItem">
        <label>Site ID: </label>
        <input id="site_id" type="text"></input>
      </div>
      <div class="editItem">
        <label>JWT: </label>
        <input id="jwt" type="text"></input>
      </div>
    </div>
    <div class="secondCol">
      <div class="editItem">
        <label>Tasks:</label>
        <select id="tasks"></select>
      </div>
      <div class="editItem">
        <label>sequences:</label>
        <select id="sequences"></select>
      </div>
      <div class="editItem">
        <label>AsBuilt:</label>
        <select id="asbuilt_func">
            <option value="none">None</option>
            <option value="passCount">PassCount</option>
            <option value="cutFill">Cut/Fill</option>
            <option value="stiffness">Stiffness</option>
            <option value="temperature">Temperature</option>
        </select>
      </div>
      <div class="editItem">
        <label>Show Legend:</label>
        <input id="show_legend" type="checkbox" value="showLegend" checked></input>
      </div>
      <div class="colorLegend">
        <div class="legend" id="color_legend"></div>
      </div>
    </div>
    <div class="thirdCol">
      <input class="button" id="view" type="button" value="View"/>
    </div>
  </div>
  <script>
    const _baseURLs = {
      QA: 'https://us-qa-api.sitelink.topcon.com',
      PROD: 'https://us-api.sitelink.topcon.com',
    }

    const _systemUnits = {
      length: {
        millimetres: { abbreviation: 'mm', ratio: 0.001 },
        centimetres: { abbreviation: 'cm', ratio: 0.01 },
        metres: { abbreviation: 'm', ratio: 1 },
        kilometres: { abbreviation: 'km', ratio: 1000 },
        inchs: { abbreviation: 'in', ratio: 0.0254 },
        feet: { abbreviation: 'ft', ratio: 0.3048 },
        us_survey_miles: { abbreviation: 'mi (survey)', ratio: 5280.0 * 1200.0 / 3937.0 },
        us_survey_feet: { abbreviation: 'US ft', ratio: 1200 / 3937 },
        yards: { abbreviation: 'yd', ratio: 0.9144 },
        miles: { abbreviation: 'mi', ratio: 1609.344 },
      },
      temperature: {
        celsius: { abbreviation: '°C', ratio: 1 },
        fahrenheit: {
          abbreviation: '°F',
          conversion: {
            toBase: (v) => (v - 32) / 1.8,
            fromBase: (v) => v * 1.8 + 32,
          },
        },
      },
    }

    function convertUnit(type, value, toUnit) {
      const unit = _systemUnits[type][toUnit.unit]
      if (unit.ratio) {
        return value/unit.ratio;
      } else {
        return unit.conversion.fromBase(value)
      }
    }

    function convertTemperature(value, unitType) {
      const unit = _lengthUnits[unitType]
      return value/unit.ratio;
    }

    function b64Raw(value) {
      return window.btoa(value).replace(/={1,2}$/, '');
    }

    // asbuilt func templates
    const _asBuiltFuncTemplates = {
      passCount: '{"alpha":true,"expr":{"type":"colorize32","color_key":"00000000","clamp":true,"sample":"last","color_map":{colormap},"expr":{"type":"asbuilt","function":"pass","component_type":"uint16"}}}',
      cutFill: '{"alpha":true,"expr":{"type":"colorize32","color_key":"00000000","clamp":true,"sample":"last","color_map":{colormap},"expr":{"type":"asbuilt","function":"hght","component_type":"real32"}}}',
      stiffness: '{"alpha":true,"expr":{"type":"colorize32","color_key":"00000000","clamp":true,"sample":"last","color_map":{colormap},"expr":{"type":"asbuilt","function":"dsty","component_type":"uint16"}}}',
      temperature: '{"alpha":true,"expr":{"type":"colorize32","color_key":"00000000","clamp":true,"sample":"last","color_map":{colormap},"expr":{"type":"asbuilt","function":"temp","component_type":"uint16"}}}',
    }

    function getAsbuiltFn(func, colormap) {
      const colors = colormap.colors;
      var color_map = []
      switch (func) {
        case 'passCount': {
          colors.forEach(function(color, index) {
            if (index ==0) return;
            color_map.push({key: index, color: `${color.substring(1)}FF`});
          });
          break;
        }
        case 'cutFill': {
          const range = colormap.range;
          const interval = range.interval;
          const offset = range.offset;
          const itemLength = colormap.colors.length;
          const middle = Math.round((itemLength - 1) / 2);
          colors.slice().reverse().forEach(function(color, index) {
            var keyValue = index < middle ? parseFloat((offset - interval*(middle-index-0.5)).toFixed(3)) : parseFloat((offset + interval*(index-middle+0.5)).toFixed(3));
            color_map.push({key: keyValue, color: `${color.substring(1)}FF`});
          });
          break;
        }
        case 'stiffness': {
          const range = colormap.range;
          const lower = Math.min(range.lower, range.upper);
          const upper = Math.max(range.lower, range.upper);
          const target = Math.max(0, range.target);
          color_map.push({key: 0, color: `${colors[3].substring(1)}FF`});
          color_map.push({key: target*lower, color: `${colors[2].substring(1)}FF`});
          color_map.push({key: target*upper, color: `${colors[1].substring(1)}FF`});
          color_map.push({key: target, color: `${colors[0].substring(1)}FF`});
          break;
        }
        case 'temperature': {
          const range = colormap.range;
          const lower = Math.min(range.lower, range.upper);
          const upper = Math.max(range.lower, range.upper);
          const buffer = Math.min(range.buffer, (upper - lower) / 2);
          color_map.push({key: 0, color: `${colors[4].substring(1)}FF`});
          color_map.push({key: lower, color: `${colors[3].substring(1)}FF`});
          color_map.push({key: lower+buffer, color: `${colors[2].substring(1)}FF`});
          color_map.push({key: upper-buffer, color: `${colors[1].substring(1)}FF`});
          color_map.push({key: upper, color: `${colors[0].substring(1)}FF`});
          break;
        }
      }
      const strColorMap = JSON.stringify(color_map);
      const strFn = _asBuiltFuncTemplates[func].replace('{colormap}', strColorMap);
      return window.btoa(strFn);
    }

    var cesiumFullScreen = false;
    var siteInfo = {};
    var transform = {};
    var tasks = {};
    var sequencesByTask = {};
    var sequenceTypes = {};
    var colorMaps = {};
    var colorMapID;
    var imageryAsBuilt;

    document.addEventListener(Cesium.Fullscreen.changeEventName, () => {
      cesiumFullScreen = !cesiumFullScreen;
      if (cesiumFullScreen) {
        $("#settings").hide();
      } else {
        $("#settings").show();
      }
    });

    $("#view").click(function(){
      if (!siteInfo.value) return;
      createLayer();
    });

    $("#env").change(function() {
        loadInfo();
    });

    $("#site_id").change(function() {
        loadInfo();
    });

    $("#jwt").change(function() {
        loadInfo();
    });

    $("#show_legend").change(function() {
      if ($("#show_legend").prop("checked")) {
        $("#color_legend").show();
      } else {
        $("#color_legend").hide();
      }
    });

    $("#tasks").change(function() {
      $("#sequences").empty();
      $("#color_legend").empty();
      var task = $("#tasks").val()
      if (task in sequencesByTask) {
        sequencesByTask[task].forEach(function(sequence) {
          $("#sequences").append($('<option>', {
            value: sequence.id,
            text: sequence.name,
          }))
        });
      }
    })

    $("#asbuilt_func").change(function() {
      if ($("#asbuilt_func").val() != 'none') {
        setColorMap();
      } else {
        $("#color_legend").empty();
      }
    })

    function getColorText(asbuiltFunc, i, colormap) {
      switch (asbuiltFunc) {
        case 'passCount':
            return 'pass ' + i;
        case 'cutFill': {
          const range = colormap.range;
          const lengthUnit = siteInfo.value.units.length;
          const interval = range.interval;
          const offset = range.offset;
          const convertedInterval = convertUnit('length', interval, lengthUnit)
          const convertedOffset = convertUnit('length', offset, lengthUnit)
          const itemLength = colormap.colors.length;
          const middle = Math.round((itemLength - 1) / 2);
          const abbrev = _systemUnits['length'][lengthUnit.unit].abbreviation;
          return i < middle ? `${(convertedOffset + convertedInterval*(middle-i-0.5)).toFixed(3)}${abbrev} .. ${(convertedOffset + convertedInterval*(middle-i+0.5)).toFixed(3)}${abbrev}` :
            `${(convertedOffset - convertedInterval*(i-middle+0.5)).toFixed(3)}${abbrev} .. ${(convertedOffset - convertedInterval*(i-middle-0.5)).toFixed(3)}${abbrev}`
        }
        case 'stiffness': {
          const range = colormap.range;
          const lower = Math.min(range.lower, range.upper);
          const upper = Math.max(range.lower, range.upper);
          const target = Math.max(0, range.target);
          switch (i) {
            case 0: return `&gt; ${target}`;
            case 1: return `${target * upper} .. ${target}`
            case 2: return `${target * lower} .. ${target * upper}`
            case 3: return `&lt; ${target * lower}`
          }
          return
        }
        case 'temperature': {
          const tempUnit = siteInfo.value.units.temperature;
          const range = colormap.range;
          const lower = Math.min(range.lower, range.upper);
          const upper = Math.max(range.lower, range.upper);

          const buffer = Math.min(range.buffer, (upper - lower) / 2);
          const abbrev = _systemUnits['temperature'][tempUnit.unit].abbreviation;
          switch (i) {
            case 0: return `&gt; ${upper}${abbrev}`;
            case 1: return `${upper - buffer}${abbrev} .. ${upper}${abbrev}`
            case 2: return `${lower + buffer}${abbrev} .. ${upper - buffer}${abbrev}`
            case 3: return `${lower}${abbrev} .. ${lower + buffer}${abbrev}`
            case 4: return `&lt; ${lower}${abbrev}`
          }
          return;
        }
      }
    }

    function setColorMap() {
        $("#color_legend").empty();
        colorMapID = '';
        var task = $("#tasks").val();
        var sequence = $("#sequences").val();
        var func = $("#asbuilt_func").val();
        var sequenceTypeID
        if (!sequencesByTask[task])
            return;
        for (var i =0; i<sequencesByTask[task].length; ++i) {
            if (sequencesByTask[task][i].id == sequence) {
                sequenceTypeID = sequencesByTask[task][i].sequenceType;
                break;
            }
        }
        if (sequenceTypeID) {
            var sequenceType = sequenceTypes[sequenceTypeID];
            if (sequenceType) {
              var defaultColorMaps = sequenceType._extra['sl::sequenceType::asbuilt']['FFP'].defaultColorMaps;
              var asbuiltFunc = $("#asbuilt_func").val();
              colorMapID = defaultColorMaps[`${asbuiltFunc}ColorMap`];
              var colorMap = colorMaps[colorMapID];
              colorMap.colormap.colors.forEach(function(color, index) {
                  if (func == 'passCount' && index ==0) return;
                  var colorText = getColorText(asbuiltFunc, index, colorMap.colormap);
                  $("#color_legend").append(`<div class="legendItem" style="background:${color}"><span>${colorText}</span></div>`);
              })
            }
        }
    }

    function addAsBuiltImages(layerSpecID) {
      var viewSite = true;
      if (!!imageryAsBuilt) {
        viewer.scene.imageryLayers.remove(imageryAsBuilt);
        viewSite = false;
      }

      var asbuiltFunc = $('#asbuilt_func').val();
      var colorMap = colorMaps[colorMapID];
      var fn = getAsbuiltFn(asbuiltFunc, colorMap.colormap);

      var baseUrl = _baseURLs[$("#env").val()];
      var siteID = $("#site_id").val();
      var jwt = $("#jwt").val();
      var transformRev = transform._rev;

      var url = `${baseUrl}/asbuilt_live/unstable/tiles/1.0.0/sites/${siteID}/layers/${layerSpecID}/{TileMatrix}/{TileCol}/{TileRow}.png?reverse_lat=true&transform=${transformRev}&fn=${fn}`
      var provider = new Cesium.WebMapTileServiceImageryProvider({
        url: new Cesium.Resource({
          url: url,
          headers: {'X-Topcon-Auth': jwt},
        }),
        tileWidth: 512,
        tileHeight: 512,
        layer: "asbuilt",
        style: "default",
        tilingScheme: new Cesium.GeographicTilingScheme(),
        tileMatrixSetID: "EPSG:4326",
        format: "image/png",
        clock: viewer.clock,
        times: times,
        credit: "Topcon AsBuit Data",
      });

      imageryAsBuilt = new Cesium.ImageryLayer(provider, {});
      viewer.scene.imageryLayers.add(imageryAsBuilt);

      provider.readyPromise.then(function () {
        var start = new Cesium.JulianDate();
        var stop = new Cesium.JulianDate().addDays(100);
        viewer.timeline.zoomTo(start, stop);

        var clock = viewer.clock;
        clock.startTime = start;
        clock.stopTime = stop;
        clock.currentTime = start;
        clock.clockRange = Cesium.ClockRange.UNBOUNDED;
        clock.multiplier = 5;
      });

      if (viewSite) {
        viewer.camera.flyTo({
          destination : Cesium.Cartesian3.fromDegrees(siteInfo.value.marker.lon, siteInfo.value.marker.lat, 1000),
        });
      }
    }

    function postLayer(layerSpec) {
      var siteID = $("#site_id").val();
      var jwt = $("#jwt").val();
      var baseUrl = _baseURLs[$("#env").val()];
      $.ajax(
        {
          url: `${baseUrl}/asbuilt_live/unstable/sites/${siteID}/layer_specs`,
          type: 'POST',
          crossDomain: true,
          headers: {'X-Topcon-Auth': jwt},
          data: JSON.stringify(layerSpec),
          success: function(result) {
            addAsBuiltImages(result.LayerSpecID);
          }
        }
      );
    }

    function createLayer() {
      var siteID = $("#site_id").val();
      var jwt = $("#jwt").val();
      var baseUrl = _baseURLs[$("#env").val()];
      var start = [$("#sequences").val()];
      if (!siteID || !jwt || !start) return;

      var bStart = b64Raw(JSON.stringify(start));
      var transforms = [{id: 'f_sequence_to_internal', context: null}];
      var bTransforms = b64Raw(JSON.stringify(transforms));

      $.ajax(
        {
          url: `${baseUrl}/rdm/v1/site/${siteID}/domain/sitelink/view/_head?start=${bStart}&limit=1&transforms=${bTransforms}`,
          headers: {'X-Topcon-Auth': jwt},
          success: function(result){
            var layerSpec = result.items[0].value;
            postLayer(layerSpec);
          }
        }
      );
    }

    function resetSiteData() {
      siteInfo = {};
      transform = {};
      tasks = {};
      sequencesByTask = {};
      sequenceTypes = {};
      colorMaps = {};
      colorMapID = null;
      imageryAsBuilt = null;
    }

    function loadInfo() {
      var siteID = $("#site_id").val()
      var jwt = $("#jwt").val()
      var baseUrl = _baseURLs[$("#env").val()]
      if (!siteID || !jwt) return

      // site info
      $.ajax(
        {
          url: `${baseUrl}/rdm/v1/site/${siteID}/domain/sitelink/view/v_sl_site`,
          headers: {'X-Topcon-Auth': jwt},
          success: function(result){
            siteInfo = result.items[0];
            console.log(siteInfo);
          },
          error: resetSiteData(),
        }
      );
      // transform
      const transformId = b64Raw('transform_gc3');
      $.ajax(
        {
          url: `${baseUrl}/rdm/v1/site/${siteID}/domain/sitelink/head/${transformId}`,
          headers: {'X-Topcon-Auth': jwt},
          success: function(result){
            transform = result;
          }
        }
      );
      // tasks
      $("#tasks").empty();
      tasks = {};
      $.ajax(
        {
          url: `${baseUrl}/rdm/v1/site/${siteID}/domain/sitelink/view/v_sl_task_by_name?limit=100`,
          headers: {'X-Topcon-Auth': jwt},
          success: function(result){
            $("#tasks").empty();
            result.items.forEach(function(item) {
              tasks[item.value.name] = item.id
              $("#tasks").append($('<option>', {
                value: item.id,
                text: item.value.name,
              }))
            })
          },
        }
      );
      // sequences
      sequencesByTask = {};
      $.ajax(
        {
          url: `${baseUrl}/rdm/v1/site/${siteID}/domain/sitelink/view/v_sl_sequence_by_task_by_order?limit=100`,
          headers: {'X-Topcon-Auth': jwt},
          success: function(result){
            result.items.forEach(function(item) {
              var sequence = {
                id: item.id,
                name: item.value.name,
                sequenceType: item.value.sequenceType,
              }
              if (item.value.task in sequencesByTask) {
                sequencesByTask[item.value.task].push(sequence)
              } else {
                sequencesByTask[item.value.task] = [sequence]
              }
            })
          }
        }
      );
      // sequence types
      sequenceTypes = {}
      $.ajax(
        {
          url: `${baseUrl}/rdm/v1/site/${siteID}/domain/sitelink/view/v_sl_sequenceType_by_class_type_by_name`,
          headers: {'X-Topcon-Auth': jwt},
          success: function(result) {
            result.items.forEach(function(item) {
                sequenceTypes[item.id] = item.value
            })
          }
        }
      );
      // color maps
      colorMaps = {};
      $.ajax(
        {
          url: `${baseUrl}/rdm/v1/site/${siteID}/domain/sitelink/view/v_sl_as_built_color_map_by_type_by_name`,
          headers: {'X-Topcon-Auth': jwt},
          success: function(result) {
            result.items.forEach(function(item) {
                colorMaps[item.id] = item.value
            })
          }
        }
      );
    }
  </script>
 </div>
 </body>
</body>
</html>
